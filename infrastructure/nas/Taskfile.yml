version: '3'

vars:
  TASK_DIR: '{{.TASKFILE_DIR}}'
  KUBECONFIG_QNAP: '{{.TASK_DIR}}/kubeconfig.yaml'
  MANIFESTS_DIR: '{{.TASK_DIR}}/../../clusters/nas'
  VAULT_ADDR: 'http://192.168.1.42:61200'
  DOCKER_HOST_NAS: 'tcp://192.168.1.20:2376'
  DOCKER_CERT_PATH: '{{.TASK_DIR}}/cert'

env:
  VAULT_ADDR: '{{.VAULT_ADDR}}'
  DOCKER_HOST: '{{.DOCKER_HOST_NAS}}'
  DOCKER_TLS_VERIFY: '1'
  DOCKER_CERT_PATH: '{{.DOCKER_CERT_PATH}}'

tasks:
  default:
    desc: Show available NAS tasks
    cmds:
      - task --list

  up:
    desc: Create K3s cluster infrastructure (Docker Compose + K3s)
    deps: [check-prereq]
    cmds:
      - task: provision
      - task: configure
      - task: kubeconfig
      - task: validate-cluster

  install:
    desc: Full NAS installation (cluster + GitOps + apps)
    deps: [check-prereq]
    cmds:
      - task: bootstrap
      - task: verify

  bootstrap:
    desc: Create cluster and bootstrap GitOps
    deps: [check-prereq]
    cmds:
      - |
        # Create cluster if kubeconfig doesn't exist or can't connect
        if [ ! -f "{{.KUBECONFIG_QNAP}}" ]; then
          echo "üöÄ Creating K3s cluster..."
          task up
        else
          echo "üîç Checking cluster connectivity..."
          export KUBECONFIG={{.KUBECONFIG_QNAP}}
          if kubectl get nodes >/dev/null 2>&1; then
            echo "‚úÖ Cluster already exists and is accessible"
          else
            echo "‚ö†Ô∏è  Kubeconfig exists but cluster not accessible, recreating..."
            task up
          fi
        fi

        # Install FluxCD
        echo "üöÄ Installing FluxCD GitOps..."
        task install-fluxcd

        # Wait for flux-system namespace to be created
        echo "‚è≥ Waiting for flux-system namespace..."
        for i in {1..30}; do
          if kubectl get namespace flux-system >/dev/null 2>&1; then
            echo "‚úÖ flux-system namespace is ready"
            break
          fi
          echo "  Waiting for flux-system namespace... ($i/30)"
          sleep 2
        done

        # Create required secrets IMMEDIATELY after FluxCD creates namespace
        echo "üîê Creating required secrets before reconciliation starts..."
        task sync-env-secrets

        # Wait for layers kustomization to be ready (creates platform-foundation)
        echo "‚è≥ Waiting for FluxCD to process layers kustomization..."
        kubectl wait --for=condition=ready --timeout=600s -n flux-system kustomization/nas-layers 2>/dev/null || {
          echo "‚ö†Ô∏è  Layers kustomization not ready, checking status..."
          kubectl get kustomization nas-layers -n flux-system 2>/dev/null || echo "nas-layers not found yet"
        }
        
        # Now wait for platform-foundation to be ready
        echo "‚è≥ Waiting for platform foundation layer to be ready..."
        kubectl wait --for=condition=ready --timeout=600s -n flux-system kustomization/nas-platform-foundation 2>/dev/null || {
          echo "‚ö†Ô∏è  Platform foundation layer not ready yet, checking status..."
          kubectl get kustomization nas-platform-foundation -n flux-system 2>/dev/null || echo "nas-platform-foundation not found yet"
        }

        echo "‚úÖ Cluster created and FluxCD bootstrapped successfully!"

  install-fluxcd:
    desc: Install FluxCD GitOps controller with GitHub bootstrap (minimal source-watcher only)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        # Skip if FluxCD is already installed
        if kubectl get namespace flux-system &>/dev/null; then
          echo "‚úÖ FluxCD is already installed"
          exit 0
        fi

        # Install flux CLI if needed
        if ! command -v flux &> /dev/null; then
          echo "üì¶ Installing flux CLI..."
          curl -s https://fluxcd.io/install.sh | sudo bash
        fi

        echo "üöÄ Installing FluxCD on NAS cluster..."

        # Check for GitHub token in environment or .env file
        if [ -z "${FLUXCD_GITHUB_TOKEN:-}" ] && [ -f ../../.env ]; then
          source ../../.env
        fi

        # Validate required environment variables
        if [ -z "${FLUXCD_OWNER:-}" ]; then
          echo "‚ùå FLUXCD_OWNER environment variable is required"
          echo "Set it in .env file or export FLUXCD_OWNER=your-github-username"
          exit 1
        fi

        if [ -z "${FLUXCD_REPOSITORY:-}" ]; then
          echo "‚ùå FLUXCD_REPOSITORY environment variable is required"
          echo "Set it in .env file or export FLUXCD_REPOSITORY=your-repo-name"
          exit 1
        fi

        if [ -n "${FLUXCD_GITHUB_TOKEN:-}" ]; then
          echo "‚úÖ Using GitHub token from environment"
          export GITHUB_TOKEN="$FLUXCD_GITHUB_TOKEN"
        else
          echo "‚ö†Ô∏è  No FLUXCD_GITHUB_TOKEN found - you will be prompted for your GitHub token"
        fi

        echo "üìã FluxCD Configuration:"
        echo "  Owner: $FLUXCD_OWNER"
        echo "  Repository: $FLUXCD_REPOSITORY"
        echo "  Path: clusters/nas (will create flux-system inside)"
        echo "  Branch: main"
        echo ""

        # Bootstrap FluxCD for NAS cluster (same version as main cluster)
        flux bootstrap github \
          --owner="$FLUXCD_OWNER" \
          --repository="$FLUXCD_REPOSITORY" \
          --branch=main \
          --path="clusters/nas" \
          --personal \
          --token-auth \
          --components="source-controller,kustomize-controller,helm-controller"

        echo "‚úÖ FluxCD installed and configured successfully!"
    status:
      - kubectl get deployment -n flux-system source-controller &>/dev/null

  sync-env-secrets:
    desc: Sync required environment to cluster (placeholder for future)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        echo "üìù NAS cluster environment sync (placeholder)"
        echo "   Future: Sync any required secrets/config from .env"

  verify:
    desc: Verify full NAS cluster deployment
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - task: status
      - task: wait-for-vault-ready
      - task: trigger-auto-unseal
      - echo "üéâ NAS cluster installation complete and verified!"


  # Helper task to check prerequisites
  check-prereq:
    desc: Check prerequisites
    silent: true
    cmds:
      - |
        if [ ! -f ".env" ]; then
          echo "ERROR: .env file not found. Copy .env.example and update with your values"
          exit 1
        fi
      - |
        if ! command -v docker &> /dev/null; then
          echo "ERROR: docker is required but not installed"
          exit 1
        fi
      - |
        if [ ! -f "{{.DOCKER_CERT_PATH}}/ca.pem" ]; then
          echo "ERROR: Docker TLS certificates not found at {{.DOCKER_CERT_PATH}}/"
          echo "Required files: ca.pem, cert.pem, key.pem"
          exit 1
        fi
      - |
        if [ ! -f "{{.DOCKER_CERT_PATH}}/cert.pem" ]; then
          echo "ERROR: Docker client certificate not found at {{.DOCKER_CERT_PATH}}/cert.pem"
          exit 1
        fi
      - |
        if [ ! -f "{{.DOCKER_CERT_PATH}}/key.pem" ]; then
          echo "ERROR: Docker client key not found at {{.DOCKER_CERT_PATH}}/key.pem"
          exit 1
        fi
      - |
        if [ ! -f "docker-compose.yaml" ]; then
          echo "ERROR: docker-compose.yaml not found in {{.TASK_DIR}}"
          exit 1
        fi
      - |
        echo "üîç Testing remote Docker connection..."
        if ! docker version >/dev/null 2>&1; then
          echo "ERROR: Cannot connect to Docker daemon at {{.DOCKER_HOST_NAS}}"
          echo "Check that:"
          echo "  - NAS Docker daemon is running with TLS enabled"
          echo "  - Certificates in {{.DOCKER_CERT_PATH}}/ are valid"
          echo "  - Network connectivity to 192.168.1.42:2376"
          exit 1
        fi
        echo "‚úÖ Remote Docker connection verified"

  provision:
    desc: "Provision K3s cluster using Docker Compose"
    deps: [check-prereq]
    cmds:
      - echo "üì¶ Starting K3s cluster with Docker Compose..."
      - |
        # Load environment variables
        if [ -f .env ]; then
          export $(cat .env | grep -v '^#' | xargs)
        fi

        # Set default SHARE_BASE if not provided
        export SHARE_BASE="${SHARE_BASE:-/share}"

        echo "Using SHARE_BASE: $SHARE_BASE"
        echo "üîó Connecting to remote Docker at {{.DOCKER_HOST_NAS}}"
        docker compose up -d
      - echo "‚è≥ Waiting for K3s to be ready..."
      - |
        for i in {1..30}; do
          if docker exec qnap-k3s kubectl get nodes >/dev/null 2>&1; then
            echo "‚úÖ K3s cluster is ready"
            break
          fi
          echo "  Waiting for K3s... ($i/30)"
          sleep 5
        done
    status:
      - docker ps | grep -q qnap-k3s

  configure:
    desc: "Configure K3s cluster"
    deps: [check-prereq]
    cmds:
      - echo "‚öôÔ∏è K3s cluster configuration complete"
      - echo "‚ÑπÔ∏è  K3s runs with built-in Traefik (can be disabled if needed)"

  kubeconfig:
    desc: "Get kubeconfig from K3s container"
    deps: [check-prereq]
    cmds:
      - |
        if [ -f "{{.KUBECONFIG_QNAP}}" ]; then
          echo "‚úÖ Kubeconfig already exists at {{.KUBECONFIG_QNAP}}"
        else
          echo "üìù Extracting kubeconfig from K3s container..."
          # Extract IP from DOCKER_HOST (format: tcp://192.168.1.42:2376)
          DOCKER_HOST_IP=$(echo $DOCKER_HOST | sed 's|tcp://||' | sed 's|:.*||')
          docker exec qnap-k3s cat /etc/rancher/k3s/k3s.yaml | \
          sed "s/127.0.0.1/$DOCKER_HOST_IP/g" > {{.KUBECONFIG_QNAP}}
          echo "‚úÖ Kubeconfig extracted and server URL updated to $DOCKER_HOST_IP"
        fi
      - |
        chmod 600 {{.KUBECONFIG_QNAP}}
        echo "üîç Validating kubeconfig..."
      - echo "‚è≥ Waiting for Kubernetes API to be ready..."
      - |
        export KUBECONFIG={{.KUBECONFIG_QNAP}}
        for i in {1..10}; do
          if kubectl get nodes >/dev/null 2>&1; then
            echo "‚úÖ Kubernetes API is ready"
            break
          fi
          echo "  Waiting for API server... ($i/10)"
          if [ $i -eq 10 ]; then
            echo ""
            echo "‚ùå Could not connect to Kubernetes API"
            echo ""
            echo "Please check:"
            echo "  - The kubeconfig file is correct"
            echo "  - The server URL in kubeconfig matches the actual K3s endpoint"
            echo "  - K3s is running: docker ps | grep qnap-k3s"
            echo ""
            echo "You can view the kubeconfig content with:"
            echo "  cat {{.KUBECONFIG_QNAP}}"
            echo ""
            exit 1
          fi
          sleep 3
        done
      - |
        echo ""
        echo "üìã Cluster status:"
        export KUBECONFIG={{.KUBECONFIG_QNAP}}
        kubectl get nodes
        echo ""
        echo "‚úÖ K3s cluster is ready!"
    status:
      - test -f {{.KUBECONFIG_QNAP}} && kubectl --kubeconfig={{.KUBECONFIG_QNAP}} get nodes >/dev/null 2>&1

  validate-cluster:
    desc: "Validate complete cluster health (nodes, networking, DNS)"
    deps: [check-prereq]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get nodes
        msg: "Cluster must be accessible before validation"
    cmds:
      - |
        echo "üîç Validating K3s cluster health..."
        echo ""

        echo "üìã Node Status:"
        kubectl get nodes -o wide
        echo ""

        echo "üåê System Pods:"
        kubectl get pods -n kube-system
        echo ""

        echo "üîç DNS Status:"
        kubectl get svc -n kube-system | grep dns || kubectl get svc -n kube-system | grep coredns
        echo ""

        # Count ready nodes
        total_nodes=$(kubectl get nodes --no-headers | wc -l | tr -d ' \n\r\t')
        ready_nodes=$(kubectl get nodes --no-headers | grep -w Ready | wc -l | tr -d ' \n\r\t')

        echo "üìä Cluster Health Summary:"
        echo "  Nodes: $ready_nodes/$total_nodes Ready"
        echo ""

        # Final validation
        if [ "$ready_nodes" -gt 0 ]; then
          echo "‚úÖ Cluster validation successful!"
          echo "   ‚Ä¢ API server: ‚úÖ Accessible"
          echo "   ‚Ä¢ Nodes: ‚úÖ $ready_nodes ready"
          echo "   ‚Ä¢ System: ‚úÖ K3s components running"
          echo ""
          echo "üöÄ Cluster is ready for workloads!"
        else
          echo "‚ö†Ô∏è  Cluster validation issues detected:"
          echo "   ‚Ä¢ No nodes are ready"
          echo ""
          echo "Run 'task nas:logs' to check container logs"
          exit 1
        fi

  check-cluster:
    desc: "Check cluster connectivity"
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f {{.KUBECONFIG_QNAP}}
        msg: |
          QNAP kubeconfig not found at {{.KUBECONFIG_QNAP}}
          Run 'task nas:kubeconfig' to extract it from the container
      - sh: kubectl get nodes &>/dev/null
        msg: |
          Cannot connect to K3s cluster
          Check if K3s is running with 'task nas:status'
    cmds:
      - echo "‚úÖ Connected to K3s cluster"
      - kubectl get nodes

  wait-for-vault-ready:
    desc: Wait for Vault to be deployed and ready (follows main cluster pattern)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for FluxCD to deploy infrastructure..."
      - |
        echo "Waiting for platform foundation kustomization to be ready..."
        kubectl wait --for=condition=ready --timeout=600s -n flux-system kustomization/nas-platform-foundation 2>/dev/null || {
          echo "‚ö†Ô∏è  Infrastructure layer not ready yet, checking status..."
          kubectl get kustomization nas-platform-foundation -n flux-system 2>/dev/null || echo "nas-platform-foundation kustomization not found"
        }
      - echo "‚è≥ Waiting for Vault HelmRelease to be ready..."
      - |
        kubectl wait --for=condition=ready --timeout=600s -n flux-system helmrelease/vault-nas 2>/dev/null || {
          echo "‚ö†Ô∏è  Vault HelmRelease not ready yet"
          kubectl get helmrelease vault-nas -n flux-system 2>/dev/null || echo "vault-nas HelmRelease not found"
        }
      - echo "‚è≥ Waiting for Vault pod to be running..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=300s
      - echo "‚úÖ Vault infrastructure is ready for bootstrap"

  trigger-auto-unseal:
    desc: Trigger auto-unseal job (managed by FluxCD)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Vault bootstrap may have failed."
    cmds:
      - |
        echo "üîê Triggering Vault auto-unseal..."

        # Check if auto-unseal job exists and create manual trigger if needed
        if kubectl get job -n vault vault-auto-unseal &>/dev/null; then
          echo "   Auto-unseal job already exists, checking status..."
          if kubectl get job -n vault vault-auto-unseal -o jsonpath='{.status.conditions[0].type}' | grep -q "Complete"; then
            echo "   ‚úÖ Auto-unseal already completed"
          else
            echo "   ‚è≥ Auto-unseal job is running..."
          fi
        else
          echo "   ‚ùå Auto-unseal job not found. FluxCD should have deployed it."
          echo "   Manual trigger: kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"
        fi

  wait-for-infrastructure:
    desc: Wait for platform foundation layer to be ready
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for platform foundation layer..."
      - |
        timeout 600 bash -c '
        while ! kubectl get kustomization -n flux-system nas-platform-foundation -o jsonpath="{.status.conditions[?(@.type==\"Ready\")].status}" | grep -q "True"; do
          echo "Platform foundation layer not ready yet..."
          sleep 10
        done'
      - echo "‚úÖ Platform foundation layer ready"

  wait-for-apps:
    desc: Wait for applications layer to be ready
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for applications layer..."
      - |
        timeout 600 bash -c '
        while ! kubectl get kustomization -n flux-system nas-apps -o jsonpath="{.status.conditions[?(@.type==\"Ready\")].status}" | grep -q "True"; do
          echo "Applications layer not ready yet..."
          sleep 10
        done'
      - echo "‚úÖ Applications layer ready"

  deploy-base:
    desc: Deploy base resources
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üì¶ Deploying base resources..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/base
    status:
      - kubectl get namespace vault 2>/dev/null

  deploy-vault:
    desc: Deploy Vault
    deps: [deploy-base]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üì¶ Deploying Vault..."
      - kubectl kustomize {{.MANIFESTS_DIR}}/vault --enable-helm | kubectl apply -f -
      - echo "‚è≥ Waiting for Vault to be ready..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=300s
    status:
      - kubectl get statefulset -n vault vault 2>/dev/null | grep -q "1/1"

  deploy-minio:
    desc: Deploy MinIO
    deps: [deploy-vault]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - kubectl create namespace minio --dry-run=client -o yaml | kubectl apply -f -
      - task: ensure-minio-secret
      - echo "üì¶ Deploying MinIO..."
      - kubectl kustomize {{.MANIFESTS_DIR}}/minio --enable-helm | kubectl apply -f -
      - echo "‚è≥ Waiting for MinIO to be ready..."
      - kubectl -n minio wait --for=condition=ready pod -l app=minio --timeout=300s
    status:
      - kubectl get deployment -n minio minio 2>/dev/null | grep -q "1/1"

  ensure-minio-secret:
    desc: Ensure MinIO root user secret exists
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - '{{.TASK_DIR}}/scripts/ensure-minio-secret.sh'
    silent: true

  post-deploy:
    desc: Post-deployment configuration
    cmds:
      - task: create-aws-secret
      - task: vault-pki
      - task: vault-auto-unseal
      - task: show-info

  create-aws-secret:
    desc: Create AWS credentials secret if available
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - '{{.TASK_DIR}}/scripts/create-aws-secret.sh'
    silent: true


  vault-init:
    desc: Initialize Vault manually (legacy method)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get statefulset -n vault vault &>/dev/null
        msg: "Vault not deployed yet. Run 'task deploy' first"
    cmds:
      - |
        echo "‚ö†Ô∏è  DEPRECATED: Use GitOps 'task nas:bootstrap' for automated setup"
        echo ""
        if kubectl -n vault get secret vault-keys &>/dev/null 2>&1; then
          echo "‚úÖ Vault is already initialized"
          exit 0
        fi

        echo "üîê Initializing Vault..."
        echo ""
        echo "Run these commands manually:"
        echo ""
        echo "export VAULT_ADDR={{.VAULT_ADDR}}"
        echo "vault operator init -key-shares=5 -key-threshold=3"
        echo ""
        echo "‚ö†Ô∏è  SAVE ALL 5 unseal keys and the root token!"
        echo ""
        echo "Then unseal Vault:"
        echo "vault operator unseal <key-1>"
        echo "vault operator unseal <key-2>"
        echo "vault operator unseal <key-3>"
        echo ""
        echo "Login with root token:"
        echo "vault login <root-token>"
        echo ""
        echo "üìù IMPORTANT: Add the root token to your .env file:"
        echo "QNAP_VAULT_TOKEN=<root-token>"
        echo ""
        echo "This token is required for the main cluster deployment to access NAS vault during bootstrap."
        echo ""
        echo "Enable KV v2 secrets engine:"
        echo "vault secrets enable -path=secret kv-v2"
        echo ""
        echo "Then run:"
        echo "  task nas:vault-secrets          # Setup MinIO password and AWS credentials"
        echo "  task nas:vault-transit          # Configure transit unseal for main K8s"

  vault-secrets:
    desc: Setup Vault secrets for MinIO and AWS
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is unsealed and you're logged in"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - '{{.TASK_DIR}}/scripts/vault-secrets-setup.sh'

  vault-unseal:
    desc: Unseal Vault using GPG-encrypted key
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Run 'task nas:vault-bootstrap' first"
    cmds:
      - |
        echo "üîê Unsealing Vault using GPG-encrypted key..."

        if vault status | grep -q "Sealed.*false"; then
          echo "‚úÖ Vault is already unsealed"
          exit 0
        fi

        if ! vault status &>/dev/null; then
          echo "‚ùå Cannot connect to Vault at {{.VAULT_ADDR}}"
          exit 1
        fi

        UNSEAL_KEY=$(gpg --quiet --batch --decrypt {{.TASK_DIR}}/unseal/unseal-keys.txt.gpg 2>/dev/null)
        vault operator unseal "$UNSEAL_KEY"

        echo "‚úÖ Vault unsealed successfully"

  vault-auto-unseal:
    desc: Deploy auto-unseal job for Vault
    deps: [deploy-vault]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Run 'task nas:vault-bootstrap' first"
    cmds:
      - echo "üì¶ Deploying Vault auto-unseal job..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/auto-unseal
      - echo "‚úÖ Auto-unseal job deployed"
      - echo ""
      - echo "To trigger manual unseal:"
      - echo "  kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"

  vault-transit:
    desc: Setup Vault transit unseal for main K8s cluster
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is unsealed and you're logged in"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - '{{.TASK_DIR}}/scripts/vault-transit-setup.sh'


  vault-pki:
    desc: Setup PKI for mTLS certificates
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is initialized and unsealed"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - echo "Setting up PKI for mTLS certificates..."
      - chmod +x {{.TASK_DIR}}/scripts/generate-pki.sh
      - '{{.TASK_DIR}}/scripts/generate-pki.sh'
    status:
      - vault kv get secret/pki/ca &>/dev/null || false

  generate-client-cert:
    desc: Generate a client certificate
    vars:
      USERNAME: '{{index .CLI_ARGS 0}}'
      EMAIL: '{{index .CLI_ARGS 1}}'
    preconditions:
      - sh: test -n "{{.USERNAME}}"
        msg: "Usage: task nas:generate-client-cert -- <username> <email>"
      - sh: test -n "{{.EMAIL}}"
        msg: "Usage: task nas:generate-client-cert -- <username> <email>"
    cmds:
      - cmd: |
          export VAULT_ADDR={{.VAULT_ADDR}}
          if ! vault token lookup &>/dev/null; then
            echo "Not authenticated to Vault. Run: vault login"
            exit 1
          fi

          # Source the functions from generate-pki.sh
          source {{.TASK_DIR}}/scripts/generate-pki.sh

          # Generate the certificate
          generate_client_cert "{{.USERNAME}}" "{{.EMAIL}}"

          echo ""
          echo "üì• Download your certificate:"
          echo "  export VAULT_ADDR={{.VAULT_ADDR}}"
          echo "  vault login  # If not already logged in"
          echo "  {{.TASK_DIR}}/scripts/download-cert.sh {{.USERNAME}}"
        shell: bash

  show-info:
    desc: Show deployment information
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    vars:
      MINIO_PASSWORD:
        sh: |
          if vault status &>/dev/null 2>&1 && vault kv get secret/minio &>/dev/null 2>&1; then
            echo "(stored in Vault at secret/minio)"
          else
            echo "changeme123 (default - run 'task nas:vault-secrets' to secure)"
          fi
    cmds:
      - |
        echo ""
        echo "‚úÖ Deployment complete!"
        echo ""
        echo "üìã Service URLs:"
        echo "  - Vault: {{.VAULT_ADDR}}"
        echo "  - MinIO API: http://192.168.1.42:61900"
        echo "  - MinIO Console: http://192.168.1.42:61901"
        echo ""
        echo "üì¶ MinIO credentials:"
        echo "  Username: admin"
        echo "  Password: {{.MINIO_PASSWORD}}"

        # Check Vault initialization status
        if ! vault status | grep -q "Initialized.*true" &>/dev/null; then
          echo ""
          echo "üîê Next step: Initialize Vault with GitOps bootstrap"
          echo "  task nas:bootstrap"
          echo ""
          echo "Or use legacy manual method:"
          echo "  task nas:vault-init"
        else
          # Check PKI status
          echo ""
          if vault kv get secret/pki/ca &>/dev/null 2>&1; then
            echo "üîí PKI Status: ‚úÖ Initialized"
            if vault kv get secret/tokens/eso-pki &>/dev/null 2>&1; then
              ESO_TOKEN=$(vault kv get -field=token secret/tokens/eso-pki 2>/dev/null || echo "<error>")
              echo "   ESO Sync Token: $ESO_TOKEN"
            fi
            echo ""
            echo "üì• Download client certificates:"
            echo "   export VAULT_ADDR={{.VAULT_ADDR}}"
            echo "   vault login"
            echo "   {{.TASK_DIR}}/scripts/download-cert.sh admin"
            echo ""
            echo "üÜï Generate new certificates:"
            echo "   task nas:generate-client-cert -- <username> <email>"
          else
            echo "üîí PKI Status: ‚ùå Not initialized"
            echo "   Run: task nas:vault-pki"
          fi

          # Check auto-unseal status
          echo ""
          if kubectl -n vault get job vault-auto-unseal &>/dev/null 2>&1; then
            echo "üîì Auto-unseal: ‚úÖ Deployed"
            echo "   Manual trigger: kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"
          else
            echo "üîì Auto-unseal: ‚ùå Not deployed"
            echo "   Run: task nas:vault-auto-unseal"
          fi
        fi

  status:
    desc: Check status of NAS cluster and GitOps
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üîç Checking NAS cluster status..."
      - echo ""
      - echo "üì¶ Docker Container:"
      - |
        if docker ps | grep -q qnap-k3s; then
          echo "  ‚úÖ qnap-k3s container is running"
          docker ps | grep qnap-k3s | awk '{print "     Image: " $2 ", Status: " $7 " " $8}'
        else
          echo "  ‚ùå qnap-k3s container not running"
          echo "     Run 'task nas:provision' to start it"
        fi
      - echo ""
      - echo "‚ò∏Ô∏è  K3s Cluster:"
      - kubectl get nodes 2>/dev/null || echo "  ‚ùå K3s not accessible (run 'task nas:kubeconfig')"
      - echo ""
      - echo "üöÄ FluxCD status:"
      - |
        if kubectl get namespace flux-system &>/dev/null 2>&1; then
          echo "  Controllers:"
          kubectl get pods -n flux-system --no-headers 2>/dev/null | awk '{print "    " $1 ": " $3}' || echo "    No controllers found"
          echo "  GitOps Layers:"
          kubectl get kustomization -n flux-system --no-headers 2>/dev/null | awk '{print "    " $1 ": " $2}' || echo "    No kustomizations found"
        else
          echo "  ‚ùå FluxCD not deployed"
        fi
      - echo ""
      - echo "üèóÔ∏è  Infrastructure status:"
      - kubectl get pods -n vault 2>/dev/null || echo "  Vault not deployed"
      - |
        export VAULT_ADDR=http://192.168.1.42:61200
        if command -v vault >/dev/null 2>&1 && vault status &>/dev/null 2>&1; then
          echo "  Vault: ‚úÖ Accessible"
        else
          echo "  Vault: ‚ùå Not accessible or sealed"
        fi
      - echo ""
      - echo "üì± Applications status:"
      - kubectl get pods -n minio 2>/dev/null || echo "  MinIO not deployed"
      - echo ""
      - echo "üîì Auto-unseal status:"
      - |
        if kubectl get cronjob vault-auto-unseal -n vault &>/dev/null 2>&1; then
          echo "  ‚úÖ Auto-unseal CronJob deployed"
          echo "     Schedule: $(kubectl get cronjob vault-auto-unseal -n vault -o jsonpath='{.spec.schedule}')"
        else
          echo "  ‚ùå Auto-unseal not deployed"
        fi
      - kubectl get jobs -n vault 2>/dev/null | grep vault-auto-unseal | tail -3 || echo "  No recent auto-unseal jobs"

  logs:
    desc: Show logs for a service or container
    vars:
      SERVICE: '{{index .CLI_ARGS 0}}'
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        case {{.SERVICE}} in
          k3s|cluster)
            echo "üìú K3s container logs:"
            docker logs qnap-k3s --tail=50
            ;;
          vault)
            echo "üìú Vault pod logs:"
            kubectl logs -n vault -l app.kubernetes.io/name=vault --tail=50
            ;;
          minio)
            echo "üìú MinIO pod logs:"
            kubectl logs -n minio -l app=minio --tail=50
            ;;
          flux)
            echo "üìú FluxCD controller logs:"
            kubectl logs -n flux-system -l app=source-controller --tail=20
            kubectl logs -n flux-system -l app=kustomize-controller --tail=20
            kubectl logs -n flux-system -l app=helm-controller --tail=20
            ;;
          *)
            echo "Usage: task nas:logs -- [k3s|vault|minio|flux]"
            echo "       task nas:logs -- cluster  # same as k3s"
            ;;
        esac

  destroy:
    desc: "Destroy FluxCD and all deployed resources (inverse of bootstrap)"
    deps: [check-prereq]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    prompt: This will remove FluxCD and all deployed resources. Are you sure?
    cmds:
      - |
        if kubectl get nodes >/dev/null 2>&1; then
          echo "üßπ Removing FluxCD and all deployed resources..."

          # Remove all flux resources
          kubectl delete gitrepository --all -n flux-system --ignore-not-found=true
          kubectl delete helmrepository --all -n flux-system --ignore-not-found=true
          kubectl delete helmrelease --all -n flux-system --ignore-not-found=true
          kubectl delete kustomization --all -n flux-system --ignore-not-found=true

          # Remove applications
          kubectl delete namespace vault --timeout=60s --ignore-not-found=true
          kubectl delete namespace minio --timeout=60s --ignore-not-found=true

          # Remove flux-system
          kubectl delete namespace flux-system --timeout=60s --ignore-not-found=true

          echo "‚úÖ FluxCD and applications removed"
        else
          echo "‚ö†Ô∏è  Cluster not accessible"
        fi
      - echo ""
      - echo "‚úÖ Destroy completed"
      - echo "‚ÑπÔ∏è  K3s cluster is still running. Use 'task nas:uninstall' to remove everything"

  uninstall:
    desc: Uninstall everything (K3s cluster + containers + configs)
    deps: [check-prereq]
    prompt: This will destroy the entire K3s cluster and containers. Are you sure?
    cmds:
      - echo "üóëÔ∏è  Destroying K3s cluster and containers..."
      - cmd: docker compose down
        ignore_error: true
      - cmd: docker container rm -f qnap-k3s
        ignore_error: true
      - echo "üßπ Cleaning up configs..."
      - cmd: rm -f {{.KUBECONFIG_QNAP}}
        ignore_error: true
      - |
        echo ""
        echo "‚úÖ Uninstall complete"
        echo "‚ÑπÔ∏è  Persistent data remains at /share/VMs/kubernetes/"
        echo "‚ÑπÔ∏è  To clean up data: ssh admin@192.168.1.42 'sudo rm -rf /share/VMs/kubernetes/*'"

  cleanup:
    desc: "Clean up stopped containers and configs"
    deps: [check-prereq]
    cmds:
      - echo "üßπ Cleaning up stopped containers..."
      - cmd: docker container prune -f
        ignore_error: true
      - cmd: docker volume prune -f
        ignore_error: true
      - echo "‚úÖ Cleanup complete"

  wait-for-vault-ready:
    desc: Wait for Vault to be deployed and ready (follows main cluster pattern)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for FluxCD to deploy infrastructure..."
      - |
        echo "Waiting for platform foundation kustomization to be ready..."
        kubectl wait --for=condition=ready --timeout=600s -n flux-system kustomization/nas-platform-foundation 2>/dev/null || {
          echo "‚ö†Ô∏è  Infrastructure layer not ready yet, checking status..."
          kubectl get kustomization nas-platform-foundation -n flux-system 2>/dev/null || echo "nas-platform-foundation kustomization not found"
        }
      - echo "‚è≥ Waiting for Vault HelmRelease to be ready..."
      - |
        kubectl wait --for=condition=ready --timeout=600s -n flux-system helmrelease/vault-nas 2>/dev/null || {
          echo "‚ö†Ô∏è  Vault HelmRelease not ready yet"
          kubectl get helmrelease vault-nas -n flux-system 2>/dev/null || echo "vault-nas HelmRelease not found"
        }
      - echo "‚è≥ Waiting for Vault pod to be running..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=300s
      - echo "‚úÖ Vault infrastructure is ready for bootstrap"

  vault-bootstrap:
    desc: Bootstrap Vault with GPG encryption via Kubernetes Job
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get statefulset -n vault vault-vault-nas >/dev/null 2>&1
        msg: "Vault StatefulSet not found. Run 'task nas:wait-for-vault-ready' first"
    cmds:
      - echo "üîÑ Deploying Vault bootstrap job to NAS cluster..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/apps/vault-bootstrap
      - |
        echo "‚è≥ Waiting for bootstrap job to complete..."
        kubectl wait --for=condition=complete job/vault-bootstrap -n vault --timeout=600s

        echo "üìã Bootstrap job logs:"
        kubectl logs job/vault-bootstrap -n vault

        echo "‚úÖ Vault bootstrap completed!"
        echo "üìÇ GPG-encrypted files now available at /share/VMs/kubernetes/vault/ on NAS"
      - |
        echo "üßπ Cleaning up bootstrap job..."
        kubectl delete job vault-bootstrap -n vault --ignore-not-found=true
