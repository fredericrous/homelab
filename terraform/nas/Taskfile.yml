version: '3'

vars:
  TASK_DIR: '{{.TASKFILE_DIR}}'
  KUBECONFIG_QNAP: '{{.TASK_DIR}}/kubeconfig.yaml'
  MANIFESTS_DIR: '{{.TASK_DIR}}/../../clusters/nas'
  VAULT_ADDR: 'http://192.168.1.42:61200'

env:
  VAULT_ADDR: '{{.VAULT_ADDR}}'

tasks:
  default:
    desc: Show available NAS tasks
    cmds:
      - task --list

  install:
    desc: Full NAS installation (FluxCD + Vault + apps)
    deps: [check-k3s]
    cmds:
      - task: bootstrap
      - task: wait-for-vault-ready
      - task: vault-bootstrap
      - task: verify

  bootstrap:
    desc: Bootstrap GitOps on existing K3s cluster
    deps: [check-k3s]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - task: install-fluxcd
      - task: sync-env-secrets
      - task: wait-for-infrastructure
      - task: wait-for-apps
      - task: show-info

  install-fluxcd:
    desc: Install FluxCD GitOps controller with GitHub bootstrap (minimal source-watcher only)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        # Skip if FluxCD is already installed
        if kubectl get namespace flux-system &>/dev/null; then
          echo "‚úÖ FluxCD is already installed"
          exit 0
        fi

        # Install flux CLI if needed
        if ! command -v flux &> /dev/null; then
          echo "üì¶ Installing flux CLI..."
          curl -s https://fluxcd.io/install.sh | sudo bash
        fi

        echo "üöÄ Installing FluxCD on NAS cluster..."

        # Check for GitHub token in environment or .env file
        if [ -z "${FLUXCD_GITHUB_TOKEN:-}" ] && [ -f ../../.env ]; then
          source ../../.env
        fi

        # Validate required environment variables
        if [ -z "${FLUXCD_OWNER:-}" ]; then
          echo "‚ùå FLUXCD_OWNER environment variable is required"
          echo "Set it in .env file or export FLUXCD_OWNER=your-github-username"
          exit 1
        fi

        if [ -z "${FLUXCD_REPOSITORY:-}" ]; then
          echo "‚ùå FLUXCD_REPOSITORY environment variable is required"
          echo "Set it in .env file or export FLUXCD_REPOSITORY=your-repo-name"
          exit 1
        fi

        if [ -n "${FLUXCD_GITHUB_TOKEN:-}" ]; then
          echo "‚úÖ Using GitHub token from environment"
          export GITHUB_TOKEN="$FLUXCD_GITHUB_TOKEN"
        else
          echo "‚ö†Ô∏è  No FLUXCD_GITHUB_TOKEN found - you will be prompted for your GitHub token"
        fi

        echo "üìã FluxCD Configuration:"
        echo "  Owner: $FLUXCD_OWNER"
        echo "  Repository: $FLUXCD_REPOSITORY"
        echo "  Path: clusters/nas/flux-system"
        echo "  Branch: main"
        echo ""

        # Bootstrap FluxCD for NAS cluster (same version as main cluster)
        flux bootstrap github \
          --owner="$FLUXCD_OWNER" \
          --repository="$FLUXCD_REPOSITORY" \
          --branch=main \
          --path="clusters/nas/flux-system" \
          --personal \
          --token-auth \
          --components="source-controller,kustomize-controller,helm-controller"

        echo "‚úÖ FluxCD installed and configured successfully!"
    status:
      - kubectl get deployment -n flux-system source-controller &>/dev/null

  sync-env-secrets:
    desc: Sync required environment to cluster (placeholder for future)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        echo "üìù NAS cluster environment sync (placeholder)"
        echo "   Future: Sync any required secrets/config from .env"

  verify:
    desc: Verify full NAS cluster deployment
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - task: status
      - task: wait-for-vault-ready
      - task: trigger-auto-unseal
      - echo "üéâ NAS cluster installation complete and verified!"


  check-k3s:
    desc: Verify K3s connectivity
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f {{.KUBECONFIG_QNAP}}
        msg: |
          QNAP kubeconfig not found at {{.KUBECONFIG_QNAP}}

          To get the kubeconfig from QNAP:
          1. SSH into QNAP: ssh admin@192.168.1.42
          2. Copy the K3s kubeconfig:
             sudo cat /etc/rancher/k3s/k3s.yaml > /tmp/k3s.yaml
          3. Exit SSH and copy to local:
             scp admin@192.168.1.42:/tmp/k3s.yaml nas/kubeconfig.yaml
          4. Update the server URL in nas/kubeconfig.yaml:
             Change https://127.0.0.1:6443 to https://192.168.1.42:6443
      - sh: kubectl get nodes &>/dev/null
        msg: |
          Cannot connect to K3s cluster
          Check if K3s is running and kubeconfig is correct
    cmds:
      - echo "‚úÖ Connected to K3s cluster"
      - kubectl get nodes

  wait-for-vault-ready:
    desc: Wait for Vault to be ready and trigger auto-unseal
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for Vault StatefulSet to be ready..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=600s
      - echo "‚úÖ Vault NAS is ready"

  trigger-auto-unseal:
    desc: Trigger auto-unseal job (managed by FluxCD)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Vault bootstrap may have failed."
    cmds:
      - |
        echo "üîê Triggering Vault auto-unseal..."
        
        # Check if auto-unseal job exists and create manual trigger if needed
        if kubectl get job -n vault vault-auto-unseal &>/dev/null; then
          echo "   Auto-unseal job already exists, checking status..."
          if kubectl get job -n vault vault-auto-unseal -o jsonpath='{.status.conditions[0].type}' | grep -q "Complete"; then
            echo "   ‚úÖ Auto-unseal already completed"
          else
            echo "   ‚è≥ Auto-unseal job is running..."
          fi
        else
          echo "   ‚ùå Auto-unseal job not found. FluxCD should have deployed it."
          echo "   Manual trigger: kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"
        fi

  wait-for-infrastructure:
    desc: Wait for infrastructure layer to be ready
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for infrastructure layer..."
      - |
        timeout 600 bash -c '
        while ! kubectl get kustomization -n flux-system nas-infrastructure -o jsonpath="{.status.conditions[?(@.type==\"Ready\")].status}" | grep -q "True"; do
          echo "Infrastructure layer not ready yet..."
          sleep 10
        done'
      - echo "‚úÖ Infrastructure layer ready"

  wait-for-apps:
    desc: Wait for applications layer to be ready  
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for applications layer..."
      - |
        timeout 600 bash -c '
        while ! kubectl get kustomization -n flux-system nas-apps -o jsonpath="{.status.conditions[?(@.type==\"Ready\")].status}" | grep -q "True"; do
          echo "Applications layer not ready yet..."
          sleep 10
        done'
      - echo "‚úÖ Applications layer ready"

  deploy-base:
    desc: Deploy base resources
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üì¶ Deploying base resources..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/base
    status:
      - kubectl get namespace vault 2>/dev/null

  deploy-vault:
    desc: Deploy Vault
    deps: [deploy-base]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üì¶ Deploying Vault..."
      - kubectl kustomize {{.MANIFESTS_DIR}}/vault --enable-helm | kubectl apply -f -
      - echo "‚è≥ Waiting for Vault to be ready..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=300s
    status:
      - kubectl get statefulset -n vault vault 2>/dev/null | grep -q "1/1"

  deploy-minio:
    desc: Deploy MinIO
    deps: [deploy-vault]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - kubectl create namespace minio --dry-run=client -o yaml | kubectl apply -f -
      - task: ensure-minio-secret
      - echo "üì¶ Deploying MinIO..."
      - kubectl kustomize {{.MANIFESTS_DIR}}/minio --enable-helm | kubectl apply -f -
      - echo "‚è≥ Waiting for MinIO to be ready..."
      - kubectl -n minio wait --for=condition=ready pod -l app=minio --timeout=300s
    status:
      - kubectl get deployment -n minio minio 2>/dev/null | grep -q "1/1"

  ensure-minio-secret:
    desc: Ensure MinIO root user secret exists
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - '{{.TASK_DIR}}/scripts/ensure-minio-secret.sh'
    silent: true

  post-deploy:
    desc: Post-deployment configuration
    cmds:
      - task: create-aws-secret
      - task: vault-pki
      - task: vault-auto-unseal
      - task: show-info

  create-aws-secret:
    desc: Create AWS credentials secret if available
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - '{{.TASK_DIR}}/scripts/create-aws-secret.sh'
    silent: true

  vault-bootstrap:
    desc: Bootstrap Vault with GPG-encrypted single key (first time only)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get statefulset -n vault vault &>/dev/null
        msg: "Vault not deployed yet. Run 'task deploy' first"
    cmds:
      - |
        if vault status &>/dev/null 2>&1 && vault status | grep -q "Initialized.*true"; then
          echo "‚úÖ Vault is already initialized"
          echo "If you need to unseal it, run: task nas:vault-unseal"
          exit 0
        fi

        echo "üîê Starting automated Vault bootstrap with GPG encryption..."
        echo ""
        echo "This will:"
        echo "  - Initialize Vault with a single unseal key (no threshold)"
        echo "  - Encrypt the key with GPG"
        echo "  - Store encrypted keys in nas/unseal/"
        echo "  - Enable KV v2 secrets engine"
        echo ""
        read -p "Continue? (y/N): " confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
          echo "Aborted"
          exit 1
        fi

        '{{.TASK_DIR}}/scripts/vault-bootstrap-keys.sh'

  vault-init:
    desc: Initialize Vault manually (legacy method)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get statefulset -n vault vault &>/dev/null
        msg: "Vault not deployed yet. Run 'task deploy' first"
    cmds:
      - |
        echo "‚ö†Ô∏è  DEPRECATED: Use 'task nas:vault-bootstrap' for automated setup"
        echo ""
        if kubectl -n vault get secret vault-keys &>/dev/null 2>&1; then
          echo "‚úÖ Vault is already initialized"
          exit 0
        fi

        echo "üîê Initializing Vault..."
        echo ""
        echo "Run these commands manually:"
        echo ""
        echo "export VAULT_ADDR={{.VAULT_ADDR}}"
        echo "vault operator init -key-shares=5 -key-threshold=3"
        echo ""
        echo "‚ö†Ô∏è  SAVE ALL 5 unseal keys and the root token!"
        echo ""
        echo "Then unseal Vault:"
        echo "vault operator unseal <key-1>"
        echo "vault operator unseal <key-2>"
        echo "vault operator unseal <key-3>"
        echo ""
        echo "Login with root token:"
        echo "vault login <root-token>"
        echo ""
        echo "üìù IMPORTANT: Add the root token to your .env file:"
        echo "QNAP_VAULT_TOKEN=<root-token>"
        echo ""
        echo "This token is required for the main cluster deployment to access NAS vault during bootstrap."
        echo ""
        echo "Enable KV v2 secrets engine:"
        echo "vault secrets enable -path=secret kv-v2"
        echo ""
        echo "Then run:"
        echo "  task nas:vault-secrets          # Setup MinIO password and AWS credentials"
        echo "  task nas:vault-transit          # Configure transit unseal for main K8s"
        # echo "  task nas:vault-bootstrap-config # Setup bootstrap configuration for AVP"

  vault-secrets:
    desc: Setup Vault secrets for MinIO and AWS
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is unsealed and you're logged in"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - '{{.TASK_DIR}}/scripts/vault-secrets-setup.sh'

  vault-unseal:
    desc: Unseal Vault using GPG-encrypted key
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Run 'task nas:vault-bootstrap' first"
    cmds:
      - |
        echo "üîê Unsealing Vault using GPG-encrypted key..."
        
        if vault status | grep -q "Sealed.*false"; then
          echo "‚úÖ Vault is already unsealed"
          exit 0
        fi
        
        if ! vault status &>/dev/null; then
          echo "‚ùå Cannot connect to Vault at {{.VAULT_ADDR}}"
          exit 1
        fi
        
        UNSEAL_KEY=$(gpg --quiet --batch --decrypt {{.TASK_DIR}}/unseal/unseal-keys.txt.gpg 2>/dev/null)
        vault operator unseal "$UNSEAL_KEY"
        
        echo "‚úÖ Vault unsealed successfully"

  vault-auto-unseal:
    desc: Deploy auto-unseal job for Vault
    deps: [deploy-vault]
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: test -f '{{.TASK_DIR}}/unseal/unseal-keys.txt.gpg'
        msg: "Encrypted unseal key not found. Run 'task nas:vault-bootstrap' first"
    cmds:
      - echo "üì¶ Deploying Vault auto-unseal job..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/auto-unseal
      - echo "‚úÖ Auto-unseal job deployed"
      - echo ""
      - echo "To trigger manual unseal:"
      - echo "  kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"

  vault-transit:
    desc: Setup Vault transit unseal for main K8s cluster
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is unsealed and you're logged in"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - '{{.TASK_DIR}}/scripts/vault-transit-setup.sh'

  # Deprecated TODO: maybe reuse to rethink cluster-vars security
  vault-bootstrap-config:
    desc: Setup bootstrap configuration for ArgoCD Vault Plugin
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is unsealed and you're logged in"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
      - sh: test -f ../.env
        msg: ".env file not found in project root. Copy .env.example to .env and configure"
    cmds:
      - '{{.TASK_DIR}}/scripts/vault-bootstrap-config.sh'

  vault-pki:
    desc: Setup PKI for mTLS certificates
    preconditions:
      - sh: vault status &>/dev/null
        msg: "Vault is not accessible at {{.VAULT_ADDR}}. Make sure Vault is initialized and unsealed"
      - sh: vault token lookup &>/dev/null
        msg: "Not authenticated to Vault. Run: vault login <root-token>"
    cmds:
      - echo "Setting up PKI for mTLS certificates..."
      - chmod +x {{.TASK_DIR}}/scripts/generate-pki.sh
      - '{{.TASK_DIR}}/scripts/generate-pki.sh'
    status:
      - vault kv get secret/pki/ca &>/dev/null || false

  generate-client-cert:
    desc: Generate a client certificate
    vars:
      USERNAME: '{{index .CLI_ARGS 0}}'
      EMAIL: '{{index .CLI_ARGS 1}}'
    preconditions:
      - sh: test -n "{{.USERNAME}}"
        msg: "Usage: task nas:generate-client-cert -- <username> <email>"
      - sh: test -n "{{.EMAIL}}"
        msg: "Usage: task nas:generate-client-cert -- <username> <email>"
    cmds:
      - cmd: |
          export VAULT_ADDR={{.VAULT_ADDR}}
          if ! vault token lookup &>/dev/null; then
            echo "Not authenticated to Vault. Run: vault login"
            exit 1
          fi

          # Source the functions from generate-pki.sh
          source {{.TASK_DIR}}/scripts/generate-pki.sh

          # Generate the certificate
          generate_client_cert "{{.USERNAME}}" "{{.EMAIL}}"

          echo ""
          echo "üì• Download your certificate:"
          echo "  export VAULT_ADDR={{.VAULT_ADDR}}"
          echo "  vault login  # If not already logged in"
          echo "  {{.TASK_DIR}}/scripts/download-cert.sh {{.USERNAME}}"
        shell: bash

  show-info:
    desc: Show deployment information
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    vars:
      MINIO_PASSWORD:
        sh: |
          if vault status &>/dev/null 2>&1 && vault kv get secret/minio &>/dev/null 2>&1; then
            echo "(stored in Vault at secret/minio)"
          else
            echo "changeme123 (default - run 'task nas:vault-secrets' to secure)"
          fi
    cmds:
      - |
        echo ""
        echo "‚úÖ Deployment complete!"
        echo ""
        echo "üìã Service URLs:"
        echo "  - Vault: {{.VAULT_ADDR}}"
        echo "  - MinIO API: http://192.168.1.42:61900"
        echo "  - MinIO Console: http://192.168.1.42:61901"
        echo ""
        echo "üì¶ MinIO credentials:"
        echo "  Username: admin"
        echo "  Password: {{.MINIO_PASSWORD}}"

        # Check Vault initialization status
        if ! vault status | grep -q "Initialized.*true" &>/dev/null; then
          echo ""
          echo "üîê Next step: Initialize Vault with automated GPG bootstrap"
          echo "  task nas:vault-bootstrap"
          echo ""
          echo "Or use legacy manual method:"
          echo "  task nas:vault-init"
        else
          # Check PKI status
          echo ""
          if vault kv get secret/pki/ca &>/dev/null 2>&1; then
            echo "üîí PKI Status: ‚úÖ Initialized"
            if vault kv get secret/tokens/eso-pki &>/dev/null 2>&1; then
              ESO_TOKEN=$(vault kv get -field=token secret/tokens/eso-pki 2>/dev/null || echo "<error>")
              echo "   ESO Sync Token: $ESO_TOKEN"
            fi
            echo ""
            echo "üì• Download client certificates:"
            echo "   export VAULT_ADDR={{.VAULT_ADDR}}"
            echo "   vault login"
            echo "   {{.TASK_DIR}}/scripts/download-cert.sh admin"
            echo ""
            echo "üÜï Generate new certificates:"
            echo "   task nas:generate-client-cert -- <username> <email>"
          else
            echo "üîí PKI Status: ‚ùå Not initialized"
            echo "   Run: task nas:vault-pki"
          fi
          
          # Check auto-unseal status
          echo ""
          if kubectl -n vault get job vault-auto-unseal &>/dev/null 2>&1; then
            echo "üîì Auto-unseal: ‚úÖ Deployed"
            echo "   Manual trigger: kubectl -n vault create job vault-manual-unseal-$(date +%s) --from=job/vault-auto-unseal"
          else
            echo "üîì Auto-unseal: ‚ùå Not deployed"
            echo "   Run: task nas:vault-auto-unseal"
          fi
        fi

  status:
    desc: Check status of NAS cluster and GitOps
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üîç Checking NAS cluster status..."
      - echo ""
      - echo "K3s nodes:"
      - kubectl get nodes || echo "K3s not accessible"
      - echo ""
      - echo "FluxCD status:"
      - |
        if kubectl get namespace flux-system &>/dev/null; then
          echo "  Controllers:"
          kubectl get pods -n flux-system --no-headers | awk '{print "    " $1 ": " $3}'
          echo "  GitOps Layers:"
          kubectl get kustomization -n flux-system --no-headers 2>/dev/null | awk '{print "    " $1 ": " $2}' || echo "    No kustomizations found"
        else
          echo "  ‚ùå FluxCD not deployed"
        fi
      - echo ""
      - echo "Infrastructure status:"
      - kubectl get pods -n vault 2>/dev/null || echo "  Vault not deployed"
      - |
        if vault status &>/dev/null 2>&1; then
          echo "  Vault: ‚úÖ Accessible"
        else
          echo "  Vault: ‚ùå Not accessible or sealed"
        fi
      - echo ""
      - echo "Applications status:"
      - kubectl get pods -n minio 2>/dev/null || echo "  MinIO not deployed"
      - echo ""
      - echo "Auto-unseal status:"
      - kubectl get jobs -n vault 2>/dev/null | grep vault-auto-unseal || echo "  Auto-unseal job not found"

  logs:
    desc: Show logs for a service
    vars:
      SERVICE: '{{index .CLI_ARGS 0}}'
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - |
        case {{.SERVICE}} in
          vault)
            kubectl logs -n vault -l app.kubernetes.io/name=vault --tail=50
            ;;
          minio)
            kubectl logs -n minio -l app=minio --tail=50
            ;;
          *)
            echo "Usage: task logs -- [vault|minio]"
            ;;
        esac

  destroy:
    desc: Remove all QNAP services
    deps: [check-k3s]
    prompt: This will DELETE all services and data. Are you sure?
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "üßπ Cleaning up K3s cluster on QNAP..."
      - cmd: kubectl delete namespace minio --timeout=60s --ignore-not-found=true
        ignore_error: true
      - cmd: kubectl delete namespace vault --timeout=60s --ignore-not-found=true
        ignore_error: true
      - cmd: kubectl delete storageclass nas-local --ignore-not-found=true
        ignore_error: true
      - cmd: kubectl delete pv --all --timeout=30s
        ignore_error: true
      - |
        # Wait for namespaces to be fully deleted
        echo "‚è≥ Waiting for namespaces to be deleted..."
        MAX_WAIT=60
        COUNTER=0
        while [ $COUNTER -lt $MAX_WAIT ]; do
          if ! kubectl get namespace minio &>/dev/null 2>&1 && ! kubectl get namespace vault &>/dev/null 2>&1; then
            echo "‚úÖ Namespaces deleted"
            break
          fi
          echo "  Still deleting namespaces... ($COUNTER/$MAX_WAIT)"
          sleep 5
          COUNTER=$((COUNTER + 5))
        done
      - |
        echo ""
        echo "‚úÖ K3s cluster cleaned up!"
        echo ""
        echo "üìã Next steps:"
        echo "1. SSH into QNAP to clean up any remaining data:"
        echo "   ssh admin@192.168.1.42"
        echo "   sudo rm -rf /share/runtime/k3s/storage/*"
        echo ""
        echo "2. Deploy fresh:"
        echo "   task nas:deploy"
        echo ""
        echo "‚ö†Ô∏è  Note: K3s itself is managed by QNAP and should not be uninstalled"

  wait-for-vault-ready:
    desc: Wait for Vault to be deployed and ready (follows main cluster pattern)
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    cmds:
      - echo "‚è≥ Waiting for FluxCD to deploy infrastructure..."
      - |
        echo "Waiting for infrastructure kustomization to be ready..."
        kubectl wait --for=condition=ready --timeout=600s -n flux-system kustomization/nas-infrastructure 2>/dev/null || {
          echo "‚ö†Ô∏è  Infrastructure layer not ready yet, checking status..."
          kubectl get kustomization nas-infrastructure -n flux-system 2>/dev/null || echo "nas-infrastructure kustomization not found"
        }
      - echo "‚è≥ Waiting for Vault HelmRelease to be ready..."
      - |
        kubectl wait --for=condition=ready --timeout=600s -n flux-system helmrelease/vault-nas 2>/dev/null || {
          echo "‚ö†Ô∏è  Vault HelmRelease not ready yet"
          kubectl get helmrelease vault-nas -n flux-system 2>/dev/null || echo "vault-nas HelmRelease not found"
        }
      - echo "‚è≥ Waiting for Vault pod to be running..."
      - kubectl -n vault wait --for=condition=ready pod -l app.kubernetes.io/name=vault --timeout=300s
      - echo "‚úÖ Vault infrastructure is ready for bootstrap"

  vault-bootstrap:
    desc: Bootstrap Vault with GPG encryption via Kubernetes Job
    env:
      KUBECONFIG: '{{.KUBECONFIG_QNAP}}'
    preconditions:
      - sh: kubectl get statefulset -n vault vault-vault-nas >/dev/null 2>&1
        msg: "Vault StatefulSet not found. Run 'task nas:wait-for-vault-ready' first"
    cmds:
      - echo "üîÑ Deploying Vault bootstrap job to NAS cluster..."
      - kubectl apply -k {{.MANIFESTS_DIR}}/apps/vault-bootstrap
      - |
        echo "‚è≥ Waiting for bootstrap job to complete..."
        kubectl wait --for=condition=complete job/vault-bootstrap -n vault --timeout=600s
        
        echo "üìã Bootstrap job logs:"
        kubectl logs job/vault-bootstrap -n vault
        
        echo "‚úÖ Vault bootstrap completed!"
        echo "üìÇ Files now available at /VMs/kubernetes/vault/ on NAS"
      - |
        echo "üßπ Cleaning up bootstrap job..."
        kubectl delete job vault-bootstrap -n vault --ignore-not-found=true
