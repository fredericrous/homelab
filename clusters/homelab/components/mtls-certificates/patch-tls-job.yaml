---
# Job to patch TLS secrets with client CA certificate for Istio mTLS
# Reads configuration from namespace annotations:
#   mtls/tls-secret-name: <tls-secret-name>
apiVersion: batch/v1
kind: Job
metadata:
  name: patch-tls-cacert
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  template:
    spec:
      # Service account is expected to exist already (created by the app)
      serviceAccountName: default  # Will be overridden by patch
      restartPolicy: Never
      containers:
      - name: patcher
        image: alpine/kubectl:1.34.1
        command: ["/bin/sh", "-c"]
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        args:
        - |
          # Get TLS secret name from namespace annotation
          TLS_SECRET_NAME=$(kubectl get namespace "$NAMESPACE" -o jsonpath='{.metadata.annotations.mtls/tls-secret-name}')
          
          if [ -z "$TLS_SECRET_NAME" ]; then
            echo "ERROR: Required namespace annotation missing: mtls/tls-secret-name"
            exit 1
          fi
          
          echo "Configuration:"
          echo "  Namespace: $NAMESPACE"
          echo "  TLS Secret: $TLS_SECRET_NAME"
          
          # Wait for the TLS secret to exist (created by cert-manager)
          echo "Waiting for TLS secret..."
          while ! kubectl get secret "$TLS_SECRET_NAME" -n "$NAMESPACE" 2>/dev/null; do
            echo "Waiting for $TLS_SECRET_NAME to be created by cert-manager..."
            sleep 5
          done
          
          echo "Getting client CA certificate..."
          CA_CERT=$(kubectl get secret client-ca-cert -n "$NAMESPACE" -o jsonpath='{.data.ca\.crt}')
          
          if [ -z "$CA_CERT" ]; then
            echo "ERROR: Could not find CA certificate at client-ca-cert/ca.crt in namespace $NAMESPACE"
            exit 1
          fi
          
          echo "Checking if cacert already exists in source secret..."
          if kubectl get secret "$TLS_SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.cacert}' 2>/dev/null | grep -q .; then
            echo "cacert key already exists in TLS secret"
            exit 0
          fi
          
          echo "Adding cacert key to TLS secret in source namespace..."
          kubectl patch secret "$TLS_SECRET_NAME" -n "$NAMESPACE" --type='json' \
            -p="[{\"op\": \"add\", \"path\": \"/data/cacert\", \"value\": \"$CA_CERT\"}]"
          
          echo "TLS secret patched successfully. Reflector will propagate it to istio-ingress."
  backoffLimit: 3